© 2018 Aaron Sami Abassi
Licensed under the Academic Free License version 3.0

C++'14 Relational Association Programming Style Guide


    In this document I will clarify the decisions I made regarding the 
    formatting of the C++'14 source code which I recently released on GitHub.  
    This style convention was developed in phases based on my experiences 
    developing the source code located at http://github.com/ASA1976/RAP-BTL in 
    order to demonstrate procedural metaprogramming in C++ for the purpose of 
    systems programming.


Naming Conventions


    Identifier naming in use pertains to the duration of the named object.  If 
    the duration is permanent, including static duration in functions and 
    everything at file or namespace scope, then each word in the name should 
    begin with a capital letter such as a function template named 
    'ContainsPosition'.  If the duration is temporary then the name should begin 
    with a lowercase letter and words should be separated by underscores such as
    a function parameter named 'base_set'.  Type names should follow permanent 
    duration convention since they convey definitions which are universal in 
    scope.


Formatting Conventions


Templates For Reference And Pointer Types

    When using a simple template to represent reference and pointer types, the 
    identifier or name of subsequent declarations always appears after the type
    specifier instead of buried within the declaration, such as is the case with 
    array references and function pointers or references.


Vertical And Horizontal Whitespace
    
    The following example demonstrates the effect with references to arrays.
    The parameter names all appear in the same column, allowing a programmer who 
    is habituated to the convention to easily identify the parameter names.

+---------> Outer scope declarative column
|   +-----> Inner scope type parameters and type specifiers column
|   |   +-> Inner scope parameter names and local variable names column
|   |   |    
--------------------------------------------------------------------------------
template <
    typename Natural,
    typename Elemental,
    Referential< Precedent< Natural, Elemental > >
        Precede,
    Referential< Consequent< Natural, Elemental > >
        Proceed,
    Referential< Concessive< Natural, Elemental > >
        Concede,
    Referential< Assortive< Elemental > >
        Equate,
    Referential< Assortive< Elemental > >
        Order
>
static inline bool
RecomposeCollection(
    Referential< Junctive< Natural, Elemental > >
        set,
    Referential< const Elemental >
        original,
    Referential< const Elemental >
        replacement
) {
    static auto
        Search = SearchCollection< Natural, Elemental, Equate, Order >;
    static auto
        Discompose = DiscomposeCollection< Natural, Elemental, Concede, Equate, Order >;
    Positional< Elemental >
        position;
    ...
}
--------------------------------------------------------------------------------

    Contrasted to the following, which uses a more traditional style convention.
    The programmer must now search laboriously for template and function 
    parameter names.  This problem becomes even worse when many template and/or
    function parameters are present.

--------------------------------------------------------------------------------
template <typename Natural, typename Elemental, Precedent<Natural, Elemental>& Precede, Consequent<Natural, Elemental>& Proceed, Concessive<Natural, Elemental>& Concede, Assortive<Elemental>& Equate, Assortive<Elemental>& Order>
static inline bool RecomposeCollection(Junctive<Natural, Elemental>& set, const Elemental& original, const Elemental& replacement)
{
    static auto Search = SearchCollection< Natural, Elemental, Equate, Order >;
    static auto Discompose = DiscomposeCollection< Natural, Elemental, Concede, Equate, Order >;
    Positional< Elemental > position;
    ...
}
--------------------------------------------------------------------------------

    The following struct template containing function references will 
    demonstrate how member names align to the same column, facilitating locating
    a member or scanning member names visually.  If multiple members are of the
    same type, each should appear on a single line followed by a comma except 
    the last which is terminated by the semicolon then followed by a blank line 
    before the next member type is specified.

+---------> Outer scope declarative column
|   +-----> Inner scope type parameters and type specifiers column
|   |   +-> Inner scope member names and prototype parameter types column
|   |   |    
--------------------------------------------------------------------------------
template <
    typename Natural,
    typename Elemental
>
struct Adjunctive {

    Referential< Locational< Junctional< Elemental > >(
        Referential< Junctive< Natural, Elemental > >
    ) >
        allocate;

    Referential< bool(
        Referential< Junctive< Natural, Elemental > >,
        Referential< Locational< Junctional< Elemental > > >
    ) >
        deallocate;

    Referential< Locational< Junctional< Elemental > >(
        Referential< Junctive< Natural, Elemental > >,
        Referential< const Elemental >
    ) >
        proclaim;

};
--------------------------------------------------------------------------------
        
    This second source code clip demonstrates what the struct template 
    definition might look like using traditional formatting.  You will notice 
    that the member names are buried within the member declaration and not easy 
    to locate by scanning.  This problem becomes worse when many members are 
    defined and when more complex return types are provided.

--------------------------------------------------------------------------------
template <typename Natural, typename Elemental>
struct Adjunctive {
    Junctional<Elemental>* (&allocate)(Junctive<Natural, Elemental>&);
    bool (&deallocate)(Junctive<Natural, Elemental>&, Junctional<Elemental>*&);
    Junctional<Elemental>* (&proclaim)(Junctive<Natural, Elemental>&, const Elemental&);
};
--------------------------------------------------------------------------------

    This next source code clip demonstrates a variable template at the file or 
    namespace scope.  In this case we have a function reference table 
    initialization where template parameters are specified to the function 
    templates.  You will notice that the type of the variable appears on the 
    line above and the variable's identifier appears at the same indentation 
    level.  You will also notice that I do not break up the function template 
    instance specification.  It is unnecessary since there is not necessarily a
    correlation within the set of specifiers from one member initializer to 
    another.

+---------> Outer scope declarative column
|   +-----> Inner scope type parameters, type specifiers and multi-line
|   |       initialization column
|   |   +-> Inner scope template non-type parameter names column
|   |   |
--------------------------------------------------------------------------------
template <
    typename Natural,
    typename Elemental,
    Referential< const Adjunctive< Natural, Elemental > >
        Adjunct,
    Referential< Assortive< Elemental > >
        Equate
>
constexpr Selective< Junctive< Natural, Elemental >, Positional< Elemental >, Natural, Elemental >
JunctionSelector = {
    JunctionComposer< Natural, Elemental, Adjunct, Equate >,
    JunctionSection< Junctive< Natural, Elemental >, Positional< Elemental >, Junctive< Natural, Elemental >, Positional< Elemental >, Natural, Elemental, Adjunct, Equate >,
    DuplicateSelection< Junctive< Natural, Elemental >, Positional< Elemental >, Natural, Elemental, Proceed< Natural, Elemental, Adjunct > >,
    EquateSelections< Junctive< Natural, Elemental >, Positional< Elemental >, Junctive< Natural, Elemental >, Positional< Elemental >, Elemental, Equate >,
    Account< Natural, Elemental >
};
--------------------------------------------------------------------------------

    Contrasted to the following, which uses a more traditional style convention.
    The variable's identifier now appears at varying positions from one file or
    namespace scope variable to the other, forcing the programmer to search for 
    it to identify if they've found the variable they are looking for.

--------------------------------------------------------------------------------
template <typename Natural, typename Elemental, Referential<const Adjunctive<Natural, Elemental>> Adjunct, Referential<Assortive<Elemental>> Equate>
constexpr Selective<Junctive<Natural, Elemental>, Positional<Elemental>, Natural, Elemental> JunctionSelector = {
    JunctionComposer<Natural, Elemental, Adjunct, Equate>,
    JunctionSection<Junctive<Natural, Elemental>, Positional<Elemental>, Junctive<Natural, Elemental>, Positional<Elemental>, Natural, Elemental, Adjunct, Equate>,
    DuplicateSelection<Junctive<Natural, Elemental>, Positional<Elemental>, Natural, Elemental, Proceed<Natural, Elemental, Adjunct>>,
    EquateSelections<Junctive<Natural, Elemental>, Positional<Elemental>, Junctive<Natural, Elemental>, Positional<Elemental>, Elemental, Equate>,
    Account<Natural, Elemental>
};
--------------------------------------------------------------------------------

