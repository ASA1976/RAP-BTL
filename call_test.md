# Relational Association Programming - Basic Template Library

## Invocation & std::function + std::bind Performance Analysis

Using Assembly output for 32-bit x86 Linux using the LLVM clang++ 7.0.1 
compiler, we compare the resulting Assembly code to deduce suitability for
real-time, embedded, microcontroller, high performance and monolithic software
systems programming.

### Source Code

The 'test_stdfunction.cpp' source code is more compact than the 
'test_invocative.cpp' because std::function and std::bind use template argument
deduction.  Template argument deduction *may* increase the amount of time 
required to compile source code.  *I have since added AssignInvokeFunction and a 
safe version which can deduce the template arguments for procedural functions 
only and updated the experiment to incorporate them for analysis*.

Both tests use exactly one inline static and one extern function and call them
from the main function with four (4) identical test cases which are included as
'test.conditions' from both test source code files.  For external linkage
the 'test_extern.cpp' source code contains (2) overloads of an extern function
using one of either the Invocative or std::function reference parameter type.
The static function is called four (4) times and passed one of each of the four
(4) test cases, then the same order is applied using the extern function.

### Assembly Output

The resulting Assembly source code generated by the clang++ compiler using
the command line 'clang++ -O -S test_invocative.cpp' was 192 lines long.  The
resulting Assembly source code generated using the command line 
'clang++ -O -S test_stdfunction.cpp' was 717 lines long.

All four (4) calls to TestStatic were expanded inline and reduced to two
Assembly statements within the emitted main function of the invocation test.
The first (3) calls to TestStatic were expanded inline and reduced to two 
Assembly statements within the emitted main function of the std::function test.
The last call to TestStatic which also involves std::bind however is more 
complex however also expanded inline.

In the case of the calls to TestExtern, Test1 and Test2 are invoked using two 
(2) stack frame layers (two layers of CALLL and RETL instructions), Test3 uses
one (1) CALLL, one (1) indirect near jump (JMPL instruction) and one (1) RETL 
and finally Test4 uses two (2) stack frame layers to perform the call in the 
invocation test.

Whereas std::function and std::bind produce a much more complex instruction set
involving runtime library support routines and can require heap allocation for 
complex lambda captures.

### Conclusion

The differences in the resulting code make the choice for real-time, embedded, 
microcontroller, high performance and monolithic software systems programming 
clear to any qualified professional.  Realizing the fact that the Relational 
Association Paradigm argument lead directly to the development of the invocation 
solution to std::function for systems programming is an exercise in computer 
science and psychology.

NB: I will be adding links to the discussed source code files in this document. 
    
* This document has been updated and corrected since it's first commit

